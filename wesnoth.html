<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>The Architecture of Open Source Applications: Battle for Wesnoth</TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 3.3  (Linux)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Fernando Carvalho">
	<META NAME="CHANGED" CONTENT="20110606;11090800">
	<META NAME="provenance" CONTENT="$Id: wesnoth.html 184 2011-05-29 21:18:57Z amy $">
	<META NAME="CHANGEDBY" CONTENT="NSI ">
	<META NAME="CHANGEDBY" CONTENT="NSI ">
	<META NAME="CHANGEDBY" CONTENT="NSI ">
	<META NAME="CHANGEDBY" CONTENT="NSI ">
	<!-- Start Google Analytics Tracker -->
	<SCRIPT SRC="wesnoth_files/ga.js"></SCRIPT>
	<SCRIPT>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1301159-2']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</SCRIPT>
	<!-- End Google Analytics Tracker -->
	<STYLE TYPE="text/css">
	<!--
		P { font-family: sans-serif }
		TD P { font-family: sans-serif }
		H1.chapterauthor { font-style: italic }
		H2.cjk { font-family: "WenQuanYi Micro Hei" }
		H2.ctl { font-family: "Lohit Hindi" }
		PRE.cjk { font-family: "WenQuanYi Micro Hei", monospace }
		CODE.cjk { font-family: "WenQuanYi Micro Hei", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<TABLE CELLPADDING=2 CELLSPACING=2 STYLE="page-break-before: always">
	<TR>
		<TD STYLE="; border: none; padding: 0in">
			<P><FONT COLOR="#000080"><A HREF="http://www.aosabook.org/en/index.html"><FONT COLOR="#000080"><IMG SRC="wesnoth_html_5c5098d5.jpg" NAME="graphics1" ALIGN=BOTTOM WIDTH=426 HEIGHT=99 BORDER=1></FONT></A></FONT>
						</P>
		</TD>
		<TD STYLE="border: none; padding: 0in">
			<P STYLE="border: none; padding: 0in"><STRONG><EM><A HREF="http://www.lulu.com/content/paperback-book/the-architecture-of-open-source-applications/10559746">A
			Arquitetura de Aplicações Open Source</A><!-- The Architecture of Open Source Applications  --></EM></STRONG>
			<BR><STRONG>Amy Brown e Greg Wilson (eds.)</STRONG> <BR>ISBN
			978-1-257-63801-7 <BR><EM><A HREF="http://www.aosabook.org/en/intro.html#license"><SPAN LANG="pt-BR">Licença</SPAN></A></EM><EM><!-- License --></EM>
			/ <EM><A HREF="http://www.aosabook.org/en/index.html#purchase"><SPAN LANG="pt-BR">Comprar</SPAN></A></EM><EM><!-- Buy --></EM>
			/ <EM><A HREF="http://www.aosabook.org/en/index.html#news"><SPAN LANG="pt-BR">Notícias</SPAN></A></EM><EM><!-- News --></EM>
			/ <EM><A HREF="http://www.aosabook.org/en/index.html#contribute"><SPAN LANG="pt-BR">Contribuições</SPAN></A></EM><EM><!-- Contribute --></EM>
			/ <EM><A HREF="http://www.aosabook.org/en/faq.html">FAQ</A></EM> 
			</P>
		</TD>
	</TR>
</TABLE>
<H1>Capítulo 25. Batalha por Wesnoth</H1>
<H1 CLASS="chapterauthor"><A HREF="http://www.aosabook.org/en/intro.html#shimooka-richard">Richard
Shimooka</A> e <A HREF="http://www.aosabook.org/en/intro.html#white-david">David
White</A></H1>
<P LANG="pt-BR">Programação tente a ser considerada simplesmente
uma atividade de resolução de problemas, onde o desenvolvedor tem
um problema e o código tem uma solução.<!-- Programming tends to be considered a straightforward problem solving activity; a developer has a requirement and codes a solution. -->
Beleza é normalmente julgada pela elegância ou efetividade da
implementação técnica; este livro está repleto com excelentes
exemplos.<!-- Beauty is often judged on the technical implementation's elegance or effectiveness; this book is replete with excellent examples. -->
Ainda além das funções computacionais imediatas, o código pode
ter um profundo efeito na vida das pessoas.<!-- Yet beyond its immediate computing functions, code can have a profound effect on people's lives. -->
Ele pode inspirar pessoas a participar e criar um novo contexto.
Infelizmente, existem sérias barreiras que impedem indivíduos de
participar em um projeto.<!-- It can inspire people to participate and create new content. Unfortunately, serious barriers exist that prevent individuals from participating in a project. --></P>
<P>Programming tends to be considered a straightforward problem
solving activity; a developer has a requirement and codes a solution.
</P>
<P>Beauty is often judged on the technical implementation's elegance
or effectiveness; this book is replete with excellent examples. Yet
beyond its immediate computing functions, code can have a profound
effect on people's lives. It can inspire people to participate and
create new content. Unfortunately, serious barriers exist that
prevent individuals from participating in a project.</P>
<P LANG="pt-BR">A maioria das linguagens de programação pede uma
alta capacitação técnica para ser utilizada, o que as deixa <FONT FACE="sans-serif">fora
do alcance de muitos.<!-- A maioria das linguagens de programação pede uma alta capacitação técnica para ser utilizada, o que as deixa fora do alcance de muitos. -->
Adicionalmente, melhorar a acessibilidade do código é tecnicamente
difícil e não é essencial para muitos programadores.<!-- In addition, enhancing the accessibility of code is technically difficult and is not necessary for many programs. -->
Isto raramente se traduz em scripts de codigo limpo ou soluções de
programação inteligentes.<!-- It rarely translates into neat coding scripts or clever programming solutions. -->
Atingir acessibilidade requer antecipação da arquitetura do projeto
e do programa, o que normalmente é contra-intuitivo para os padrões
normais de programação.<!-- Achieving accessibility requires considerable forethought in project and program design, which often runs counter-intuitive to normal programming standards. -->
Além disso, a maioria dos projetos depende de estabelecer uma equipe
de profissionais capacitada de quem se espera um trabalho de alto
nível.<!-- Moreover most projects rely upon an established staff of skilled professionals that are expected to operate at a reasonably high level. -->
Eles não requerem recursos adicionais de programação. Portanto,
acessibilidade de código fica para mais adiante, se chegar a ser
considerada.<!-- They do not require additional programming resources. Thus, code accessibility becomes an afterthought, if considered at all. -->
</FONT>
</P>
<P>Most programming languages require significant technical expertise
to utilize, which is out of reach for many. In addition, enhancing
the accessibility of code is technically difficult and is not
necessary for many programs. It rarely translates into neat coding
scripts or clever programming solutions. Achieving accessibility
requires considerable forethought in project and program design,
which often runs counter-intuitive to normal programming standards.
Moreover most projects rely upon an established staff of skilled
professionals that are expected to operate at a reasonably high
level. They do not require additional programming resources. Thus,
code accessibility becomes an afterthought, if considered at all.</P>
<P><SPAN LANG="pt-BR">Nosso projeto, a Batalha por Wesnoth, tenta
endereçar este problema desde o início. O programa é um jogo
estratégia e fantasia, produzido no modelo de código livre, baseado
na licença GPL2.<!-- Our project, the Battle for Wesnoth, attempted to address this issue from its origins. The program is a turn-based fantasy strategy game, produced in an open source model based on a GPL2 license. -->
Ele tem atingido um sucesso moderado, com acima de quatro milhoes de
downloads até o momento da escrita deste texto. Apesar desta métrica
impressionante, nós acreditamos que a real beleza de nosso projeto é
o modelo de desenvolvimento que permite que grupos de voluntários
com diversos níveis de capacitação possam interagir de forma
produtiva.<!-- Our project, the Battle for Wesnoth, attempted to address this issue from its origins. The program is a turn-based fantasy strategy game, produced in an open source model based on a GPL2 license. It has been a moderate success, with over four million downloads at the time of this writing. While this is an impressive metric, we believe the real beauty of our project is the development model that allowed a band of volunteers from widely different skill levels to interact in a productive way. --></SPAN></P>
<P LANG="pt-BR">Melhorar a inteligibilidade não era um objetivo vago
definido pelos desenvolvedores, era visto como essencial para a
sobrevivência do projeto. A abordagem de código livre do Wesnoth
imaginava que o projeto poderia não receber imediatamente um número
grande de desenvolvedores de alto nível. Tornar o projeto acessível
para um grande número de contribuidores, com variados níveis de
proficiência poderia garantir a viabilidade do projeto à
longo-prazo.</P>
<P>Enhancing accessibility was not a vague objective set by
developers, it was viewed as essential for the project's survival.
Wesnoth's open source approach meant that the project could not
immediately expect large numbers of highly skilled developers. Making
the project accessible to a wide a number of contributors, with
varying skill levels, would ensure its long-term viability.</P>
<P><SPAN LANG="pt-BR">Nossos desenvolvedores tem tentado definir as
fundações para a ampliação da acessibilidade desde as primeiras
iterações. Isto deveria ter inegáveis consequências para todos os
aspectos da arquitetura de programção. As principais decisões
foram feitas com este objetivo em mente. Neste capítulo será
apresentado um estudo aprofundado que examina nosso programa com foco
nos esforços para aumentar esta acessibilidade.<!-- Our developers attempted to lay the foundations for broadening accessibility right from its earliest iteration. This would have undeniable consequences for all aspect of the programming architecture. Major decisions were made largely with this objective in mind. This chapter will provide an in-depth examination of our program with a focus on the efforts to increase accessibility. --></SPAN></P>
<P><SPAN LANG="pt-BR">A primeira parte deste capítulo apresenta uma
visão geral sobre a programação do projeto, abrangendo a linguagem
utilizada, dependências e arquitetura. A segunda parte irá focar na
linguagem de armazenamento de dados única do Wesnoth, conhecida como
Wesnoth Markup Language (WML). Serão explicadas as funções
específicas do WML, com uma enfase especial nos seus efeitos em
unidades dos jogos. A sesão seguinte cobre a implementação para
multi-jogador e programas externos. O capítulo termina com algumas
observações finais sobre os desafios e a ampliação da
participação de desenvolvedores.<!-- The first part of this chapter offers a general overview of the project's programming, covering its language, dependencies and architecture. The second part will focus on Wesnoth's unique data storage language, known as Wesnoth Markup Language (WML). It will explain the specific functions of WML, with a particular emphasis on its effects on in-game units. The next section covers multiplayer implementation and external programs. The chapter will end with some concluding observations on our structure and the challenges of broadening participation. --></SPAN></P>
<H2 CLASS="western">25.1. Resumo do Projeto</H2>
<P LANG="pt-BR">O núcleo do Wesnoth foi escrito em C++, totalizando
por volta de 200 mil linhas no momento desta publicação. Ele
representa a parte principal do jogo, aproximadamente metade do
código total, sem nenhum conteúdo. O programa também permite que o
conteúdo do jogo seja definido em uma única linguagem conhecida
como Wesnoth Markup Language (WML). O jogo conta com outras 250 mil
linhas de código WML. Esta proporção tem alterado durante a
existência do projeto. Enquanto o programa amadurece, o conteúdo de
jogo que é escrito em C++ tem sido reescrito, de forma que WML pode
ser usado para definir sua operação. A Figura 25.1 tráz uma visão
simplificada da arquitetura do programa, areas destacadas são
mantidas pelos desenvolvedores Wesnoth, enquanto áreas brancas são
dependências externas.<!-- Wesnoth's core engine is written in C++, totalling around 200,000 lines at the time of this publication. This represents the core game engine, approximately half of the code base without any content. The program also allows in game content to be defined in a unique data language known as Wesnoth Markup Language (WML). The game ships with another 250,000 lines of WML code. The proportion has shifted over the project's existence. As the program matured, game content that was hardcoded in C++ has increasingly been rewritten so that WML can be used to define its operation. Figure  25.1 gives a rough picture of the program's architecture; green areas are maintained by Wesnoth developers, while white areas are external dependencies. --></P>
<P><BR><BR>
</P>
<DIV ID="fig.wes.arch" DIR="LTR">
	<P><IMG SRC="wesnoth_html_m19c4d0b0.gif" NAME="graphics2" ALIGN=BOTTOM WIDTH=356 HEIGHT=121 BORDER=0>
		</P>
	<P>Figure&nbsp;25.1: <SPAN LANG="pt-BR">Arquitetura do programa<!-- Program Architecture --></SPAN></P>
</DIV>
<P LANG="pt-BR">Em geral, as tentativas dos projetos em minimizar
dependências na maioria dos casos de forma a maximizar a
portabilidade do aplicativo. Isto traz o benefício adicional de
reduzir a complixidade do programa, e diminuir a ncessidade de
desenvolvedores para aprender as nuancias do grande número de APIs
de terceiros.<!-- Overall, the project attempts to minimize dependencies in most cases so as to maximize the portability of the application. This has the added benefit of reducing the program's complexity, and decreases the need for developers to learn the nuances of a large number of third party APIs. -->
Ao mesmo tempo, o uso controlado de algumas dependências pode
atingir o mesmo efeito. Por exemplo, Wesnoth usa o Simple Directmedia
Layer (SDL) para vídeo, controle de E/S e manupulação de eventos.
Ele foi escolhido por ser fácil usar e prover uma interface comum de
E/S para várias plataformas. Isto permite que ele seja portável
para uma ampla lista de plataformas, outra alternativa seria
codificar para APIs específicas em diferentes plataformas.
Entretanto isto tem um preço, é mais difícil de tirar vantagens de
funcionalidades específicas de alguma plataforma. SDL também tem
uma família de bibliotecas que acompanham que são usados pela
Wesnoth para vários objetivos:<!-- At the same time, the prudent use of some dependencies can actually achieve the same effect. For example, Wesnoth uses the Simple Directmedia Layer (SDL) for video, I/O and event handling. It was chosen because it is easy to use and provides a common I/O interface across many platforms. This allows it to be portable to a wide array of platforms, rather than the alternative of coding to specific APIs on different platforms. This comes at a price however; it is harder to take advantage of some platform specific features. SDL also has an accompanying family of libraries that are used by Wesnoth for various purposes: --></P>
<UL>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">SDL_Mixer para audio
	e som<!-- for audio and sound --></P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">SDL_Image para
	carregar imagens PNG e outros formatos de imagem<!-- for loading PNG and other image formats -->
		</P>
	<LI><P LANG="pt-BR">SDL_Net para entrada e saída de rede<!-- for network I/O --></P>
</UL>
<P LANG="pt-BR">Adicionalmente, Wesnoth utiliza várias outras
bibliotecas:<!-- Additionally, Wesnoth uses several other libraries: --></P>
<UL>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Otimizada para uma
	variedade de funções avançadas de C++<!-- Boost for a variety of advanced C++ features --></P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Pango e Cairo para
	fontes internacionalizadas<!-- Pango with Cairo for internationalized fonts --></P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">zlib para compressão<!-- zlib for compression --></P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Python e Lua para
	programação de scripts<!-- Python and Lua for scripting support --></P>
	<LI><P LANG="pt-BR">GNU gettext para internacionalização<!-- for internationalization --></P>
</UL>
<P LANG="pt-BR">Na arquitetura do Wesnoth, o uso de objetos WML, como
dicionários string com nós filhos – bastante onipresente. Vários
objetos podem ser contruidos a partir de nós WML, e também se
serializar como um nó WML. Algumas partes do motor mantém dados no
formato baseado em dicionários WML, interpretando diretamente ao
invés de parseando isso em estruturas de dados C++.<!-- Throughout Wesnoth's engine, the use of WML objects—that is, string dictionaries with child nodes—is fairly ubiquitous. Many objects can be constructed from a WML node, and also serialize themselves to a WML node. Some parts of the engine keep data in this WML dictionary based format, interpreting it directly rather than parsing it into a C++ data structure. --></P>
<P LANG="pt-BR">Wesnoth utiliza vários subsistemas importantes, a
maioria dos quais são tão auto-contídos quanto possível. Esta
estrutura segmentada tem vantagens para acessibilidade. Uma parte
interessada pode facilmente trabalhar um código em uma área
específica e introduzir mudanças sem demandar o resto do programa.
Uma subdivisão inclui:<!-- Wesnoth utilizes several important subsystems, most of which are as self-contained as possible. This segmented structure has advantages for accessibility. An interested party can easily work a code in a specific area and introduce changes without damaging the rest of the program. The major subdivisions include: --></P>
<UL>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Um parseador WML com
	pre-processamento<!-- A WML parser with preprocessor --></P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Módulos de E/S
	básica que abstraem bibliotecas subjacentes e chamadas de sistema –
	um módulo de vídel, um módulo de som, um módulo de rede<!-- Basic I/O modules that abstract underlying libraries and system calls—a video module, a sound module, a network module 
 -->
		</P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Um módulo GUI
	contendo implementação de widget de botões, listas, menus e etc.<!-- A GUI module containing widget implementations for buttons, lists, menus, etc. -->
		</P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Um módulo de
	apresentação para o quadro do jogo, unidades animações e etc.<!-- A display module for rendering the game board, units, animations, and so forth -->
		</P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Um módulo de IA<!-- An AI module -->
		</P>
	<LI><P LANG="pt-BR" STYLE="margin-bottom: 0in">Um módulo
	pathfinding que inclui várias funções utilitárias para lidar com
	um quadro de jogo hexagonal<!-- A pathfinding module that includes many utility functions for dealing with a hexagonal gaming board -->
		</P>
	<LI><P LANG="pt-BR">Um módulo de geração de mapas para gerar
	diferentes tipos de mapas randômicos.<!-- A map generation module for generating different kinds of random maps -->
		</P>
</UL>
<P LANG="pt-BR">Existem também diferentes módulos para controlar
diferentes partes do fluxo do jogo:<!-- There are also different modules for controlling different parts of the game flow --></P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">O módulo <I>titlescreen</I>, para
	controlar a apresentação da tela inicial.<!-- The titlescreen module, for controlling display of the title screen. -->
		</P>
	<LI><P STYLE="margin-bottom: 0in">O módulo storyline, para
	apresentar sequência de corte de cena.<!-- The storyline module, for showing cut-scene sequences -->
		</P>
	<LI><P STYLE="margin-bottom: 0in">O módulo lobby, para apresentar e
	permitir a configuração de jogos no servidor multiplayer.<!-- The lobby module, for displaying and allowing setup of games on the multiplayer server -->
		</P>
	<LI><P>O módulo “play game” que controla a jogabilidade
	principal.</P>
</UL>
<P><SPAN LANG="pt-BR">O módulo “play game” e o módulo de
apresentação principal são os maiores dentro do Wesnoth. Seu
objetivo é pouco definidas, porque suas funções tendem a mudar
sempre e portanto são difíceis de ter uma clara especificação.
Consequentemente, o módulo tem normalmente tem o perigo de
apresentar o anti-padrão </SPAN><SPAN LANG="pt-BR"><I>Blob</I></SPAN><SPAN LANG="pt-BR">
sobre seus programas historicamente, tornando-se grandes segmento
dominantes sem um comportamento bem definido. O código nos módulos
</SPAN><SPAN LANG="pt-BR"><I>display</I></SPAN><SPAN LANG="pt-BR"> e
</SPAN><SPAN LANG="pt-BR"><I>play game</I></SPAN><SPAN LANG="pt-BR">
são regularmente revistos para ver se algo pode ser separado em
outro módulo. <!-- The "play game" module and the main display module are the largest within Wesnoth. Their purpose is the least well defined, as their function is ever-changing and thus difficult to have a clear specification for. Consequently, the modules has often been in danger of suffering from the Blob anti-pattern over the program's history—i.e., becoming huge dominant segments without well-defined behaviors. The code in the display and play game modules are regularly reviewed to see if any of it can be separated into a module of its own. --></SPAN></P>
<P><SPAN LANG="pt-BR">Existe também funcionalidades antigas que são
parte do projeto com um todo, mas estão separadas do programa
principal. Isto inclui o servidor multiplayer que possibilita o jogo
em rede, bem como o servidor de conteúdo que possibilita usuários
fazer upload do seu conteúdo para um servidor comum visando
compartilhar com outros. Ambos são escritos em C++. <!-- There are also ancillary features that are part of the overall project, but are separate from the main program. This includes a multiplayer server that facilitates multiplayer network games, as well as a content server that allows users to upload their content to a common server and share it with others. Both are written in C++. --></SPAN></P>
<H2 CLASS="western">25.2. Wesnoth Markup Language</H2>
<P LANG="pt-BR">Como um motor de jogos extensivo, Wesnoth utiliza uma
linguagem de dados simples para armazenar e recuperar todos os dados
do jogo. Apesar de ter se considerado XML inicialmente, nós
decidimos que nós deveríamos buscar algo um pouco mais amistoso
para usuários não técnicos, e um pouco mais relaxado com respeito
ao uso de dados visuais. Portanto, nós desenvolvemos nossa própria
linguagem de dados, chamada Wesnoth Markup Language (WML). Isto foi
planejado com vistas ao usuário menos técnico, esperando que mesmo
usuários que achem Python e HTML intimidador possam ser capazes de
entender arquivos WML. Todos os dados do jogo Wesnoth são
armazenados em WML, incluindo definições de unidades, campanhas,
cenários, definições da GUI, e outras configurações da lógica
do jogo. <!-- As an extensible game engine, Wesnoth uses a simple data language to store and load all game data. Although XML was considered initially, we decided that we wanted something a little more friendly to non-technical users, and a little more relaxed with regard to use of visual data. We therefore developed our own data language, called Wesnoth Markup Language (WML). It was designed with the least technical of users in mind: the hope was that even users who find Python or HTML intimidating would be able to make sense of a WML file. All Wesnoth game data is stored in WML, including unit definitions, campaigns, scenarios, GUI definitions, and other game logic configuration. --></P>
<P LANG="pt-BR">A WML compartilha os mesmos atributos básicos do
XML: elementos e atributos, enquanto ela não suporta texto dentro
dos elementos.  Atributos WML são representados simplesmente como um
dicionário mapeando strings para strings, com a lógica da
programação responsável pela interpretação dos atributos. Um
exemplo simples de WML é uma definição truncada para a unidade
Elvish Fighter dentro do jogo: <!-- WML shares the same basic attributes as XML: elements and attributes, though it doesn't support text within elements. WML attributes are represented simply as a dictionary mapping strings to strings, with the program logic responsible for interpretation of attributes. A simple example of WML is a trimmed definition for the Elvish Fighter unit within the game: --></P>
<P><BR><BR>
</P>
<PRE CLASS="western">[unit_type]
    id=Elvish Fighter
    name= _ &quot;Elvish Fighter&quot;
    race=elf
    image=&quot;units/elves-wood/fighter.png&quot;
    profile=&quot;portraits/elves/fighter.png&quot;
    hitpoints=33
    movement_type=woodland
    movement=5
    experience=40
    level=1
    alignment=neutral
    advances_to=Elvish Captain,Elvish Hero
    cost=14
    usage=fighter
    {LESS_NIMBLE_ELF}
    [attack]
        name=sword
        description=_&quot;sword&quot;
        icon=attacks/sword-elven.png
        type=blade
        range=melee
        damage=5
        number=4
    [/attack]
[/unit_type]</PRE><P>
<SPAN LANG="pt-BR">Por considerar internacionalização importante no
</SPAN><SPAN LANG="pt-BR"><I>Wesnoth</I></SPAN><SPAN LANG="pt-BR">,
WML tem suporte direto para isso: valores de atributos que apresentam
um </SPAN><SPAN LANG="pt-BR"><I>underscore</I></SPAN><SPAN LANG="pt-BR">
prefixado são traduzíveis. Qualquer </SPAN><SPAN LANG="pt-BR"><I>string</I></SPAN><SPAN LANG="pt-BR">
traduzível é convertida usando o GNU </SPAN><SPAN LANG="pt-BR"><I>gettext</I></SPAN><SPAN LANG="pt-BR">
para a versão traduzida quando o WML é interpretado. <!-- Since internationalization is important in Wesnoth, WML does have direct support for it: attribute values which have an underscore prefix are translatable. Any translatable string is converted using GNU gettext to the translated version of the string when the WML is parsed. --></SPAN></P>
<P LANG="pt-BR">Ao invés de ter diferentes documentos WML, <I>Wesnoth</I>
optou pela abordagem de que todos os dados do jogo sejam apresentados
para o <I>engine</I> do jogo em um único documento. Isto permite uma
única variável global possa manter o documento, e quando o jogo for
carregado todas as definições de unidades, por exemplo, são
carregadas através da procura por elementos com nome <I>unit_type</I>
dentro do elemento <I>units</I>. <!-- Rather than have many different WML documents, Wesnoth opts for the approach of all main game data being presented to the game engine in just a single document. This allows for a single global variable to hold the document, and when the game is loaded all unit definitions, for instance, are loaded by looking for elements with the name unit_type within a units element. --></P>
<P>Apesar de todos os dados serem armazenados em um único documento
WML conceitual, este deverá ser <B>unwieldy</B><SPAN STYLE="font-weight: normal">
</SPAN><SPAN LANG="pt-BR"><SPAN STYLE="font-weight: normal">para ter
tudo em um único arquivo. Wesnoth então suporta um pré-processador
que é executado sobre todo o WML antes da interpretação. Este
proprocessador permite um arquivo a incluir o conteúdo de outro
arquivo, ou um diretório inteiro. Por exemplo: <!-- Though all data is stored in a single conceptual WML document, it would be unwieldy to have it all in a single file. Wesnoth therefore supports a preprocessor that is run over all WML before parsing. This preprocessor allows one file to include the contents of another file, or an entire directory. For instance: --></SPAN></SPAN></P>
<PRE CLASS="western" STYLE="margin-bottom: 0.2in">{gui/default/window/}</PRE><P LANG="pt-BR">
irá incluir todos os arquivos .cfg de dentro do diretório
gui/default/window/. <!-- will include all the .cfg files within gui/default/window/. --></P>
<P><SPAN LANG="pt-BR">Considerando que WML pode se tornar muito
extensa, o pre-processador também permite que macros sejam definidas
para condensar os conceitos. Por exemplo, a macro {LESS_NIMBLE_ELF}
na definição do Elvish Fighter é uma chamada para a macro que
torna certas unidades elfo menos </SPAN><SPAN LANG="pt-BR"><B>nimble</B></SPAN><SPAN LANG="pt-BR">
em certas condições, como quando eles estão parados em uma
floresta: <!-- Since WML can become very verbose, the preprocessor also allows macros to be defined to condense things. For instance, the {LESS_NIMBLE_ELF} invocation in the definition of the Elvish Fighter is a call to a macro that makes certain elf units less nimble under certain conditions, such as when they are stationed in a forest: --></SPAN></P>
<PRE CLASS="western">#define LESS_NIMBLE_ELF
    [defense]
        forest=40
    [/defense]
#enddef</PRE><P LANG="pt-BR">
Este projeto tem como vantagem tornar o motor desacoplado de como o
documento WML é quebrado em arquivos. É responsibilidade dos
autores WML decidir como estruturar e dividir todos os dados do jogo
em diferentes arquivos e diretórios. <!-- This design has the advantage of making the engine agnostic to how the WML document is broken up into files. It is the responsibility of WML authors to decide how to structure and divide all game data into different files and directories. --></P>
<P><SPAN LANG="pt-BR">Quando o motor do jogo carrega o documento WML,
ele também define alguns símbolos do pre-processador, de acordo com
várias configurações do jogo. Por exemplo, uma campanha Wesnoth
pode definir diversas configurações de dificuldade, com cada
configuração de dificuldade resultando em um símbolo de
preprocessamento diferente sendo definido. Como um exemplo, um modo
comum de variar a dificuldade é variando a quantidade de recursos
dado para um oponente (representado por ouro). Para facilitar isto,
uma macro WML é definida assim: <!-- When the game engine loads the WML document, it also defines some preprocessor symbols according to various game settings. For instance, a Wesnoth campaign can define different difficulty settings, with each difficulty setting resulting in a different preprocessor symbol being defined. As an example, a common way to vary difficulty is by varying the amount of resources given to an opponent (represented by gold). To facilitate this, there is a WML macro defined like this: --></SPAN></P>
<PRE CLASS="western">#define GOLD EASY_AMOUNT NORMAL_AMOUNT HARD_AMOUNT
  #ifdef EASY
    gold={EASY_AMOUNT}
  #endif
  #ifdef NORMAL
    gold={NORMAL_AMOUNT}
  #endif
  #ifdef HARD
    gold={HARD_AMOUNT}
  #endif
#enddef</PRE><P LANG="pt-BR">
Esta macro pode ser invocada usando, por exemplo, {GOLD 50 100 200}
dentro da definição de um oponente para definir quanto ouro o
oponente tem baseado no grau de dificuldade. <!-- This macro can be invoked using, for instance, {GOLD 50 100 200} within the definition of an opponent to define how much gold the opponent has based on the difficulty level. --></P>
<P LANG="pt-BR">Considerando que o WML seja procesado
condicionalmente, se algum dos símbolos providos pelo documento WML
mudar durante a execução do motor Wesnoth, todo o documento WML
precisa ser recarregado e processado. Por exemplo, quando o usuário
inicia o jogo, o documento WML é carregado e as campanhas
disponíveis entre outras coisas são carregadas. Mas então, se o
usuário escolhe para começar uma campanha e escolhe um certo nível
de dificuldade, Easy por exemplo, então todo o documento terá que
ser recarregado com o nível EASY definido. <!-- Since the WML is processed conditionally, if any of the symbols provided to the WML document change during execution of the Wesnoth engine, the entire WML document must be re-loaded and processed. For instance, when the user starts the game, the WML document is loaded and available campaigns among other things are loaded. But then, if the user chooses to start a campaign and chooses a certain difficulty level—easy for instance—then the entire document will have to be re-loaded with EASY defined. --></P>
<P LANG="pt-BR">Este projeto é conveniente no qual um único
documento contém todos os dados do jogo, e que símbolos possam
permitir configuração simples do documento WML. Entretanto, como um
projeto bem sucedido, mais e mais conteúdo torna-se disponível para
Wesnoth, incluindo muito conteúdo que pode ser descido via internet-
onde todo termina inserido na árvore de documentos principal – o
que implica que documentos WML tenham um tamanho de vários
megabytes. Isto tem se tornado um problema de performance para
Wesnoth: Carregar os documentos pode tormar de um minuto em alguns
computadores, causando demoras em-jogo cada vez que um documento
precisa ser recarregado. Adicionalmente, é utilizado uma quantidade
substancial de memória. Algumas medidas são usadas para
contabilizar isso: quando uma campanha é carregada, ela tem um
símbolo único para aquela campanha definido no preprocessador. Isto
significa que qualquer conteúdo específico para a campanha pode
usar #ifdef para somente ser usado quando a campanha for necessária.
<!-- This design is convenient in that a single document contains all game data, and that symbols can allow easy configuration of the WML document. However, as a successful project, more and more content is available for Wesnoth, including much downloadable content—all of which ends up inserted into the core document tree—which means the WML document is many megabytes in size. This has become a performance issue for Wesnoth: Loading the document may take up to a minute on some computers, causing delays in-game any time the document needs to be reloaded. Additionally, it uses a substantial amount of memory. Some measures are used to counter this: when a campaign is loaded, it has a symbol unique to that campaign defined in the preprocessor. This means that any content specific to that campaign can be #ifdefed to only be used when that campaign is needed. --></P>
<P><SPAN LANG="pt-BR">Adicionalmente, Wesnoth usa um sistema de cache
para dinamizar a versão totalmente preprocessada do documento WML
para um dado conjunto de definições principais. Naturalmente este
sistema de cache precisa inspecionar a timestamp de todos os arquivos
WML para para que se algum tiver sido alterado, o documento cacheado
seja reprocessado.<!-- Additionally, Wesnoth uses a caching system to cache the fully preprocessed version of the WML document for a given set of key definitions. Naturally this caching system must inspect the timestamp of all WML files so that if any have changed, the cached document is regenerated. --></SPAN></P>
<H2 CLASS="western">25.3. Unidades no Wesnoth<!-- Units in Wesnoth --></H2>
<P><SPAN LANG="pt-BR">Os protagonistas no Wesnoth são suas unidades,
Um Elvish Fighter e um Elvish Shaman devem lutar contra um Troll
Warrior e um Orcish Grunt. Todas unidades compartilham o mesmo
comportamento básico, entretanto muitas tem habilidades especiais
que alteram o fluxo normal da jogabilidade. Por exemplo, um Troll
regenera um pouco de sua saúdo a cada rodada, um Elvish Shaman torna
lentos seus oponentes com uma raiz encantada, e um Wose é invisível
dentro da floresta.<!-- The protagonists of Wesnoth are its units. An Elvish Fighter and an Elvish Shaman might battle against a Troll Warrior and an Orcish Grunt. All units share the same basic behavior, but many have special abilities that alter the normal flow of gameplay. For example, a troll regenerates some of its health every turn, an Elvish shaman slows its opponents with an entangling root, and a Wose is invisible in a forest. --></SPAN></P>
<P><SPAN LANG="pt-BR">Qual é a melhor forma para representar isto em
um motor de jogo? É tentador fazer uma classe para a unidade base em
C++, com diferentes unidades derivadas dela. Por exemplo, uma casse
da unidade Wose poderia derivar desta unidade, e cada unidade poderia
ter uma função virtual bool is_invisible() const, que retorna
falso, a qual a unidade Wose sobrescreve, retornando verdadeiro se a
unidade estiver na floresta.</SPAN><!-- What is the best way to represent this in an engine? It is tempting to make a base unit class in C++, with different types of units derived from it. For instance, a wose_unit class could derive from unit, and unit could have a virtual function, bool is_invisible() const, which returns false, which the wose_unit overrides, returning true if the unit happens to be in forest. --></P>
<P><SPAN LANG="pt-BR">Tal abordagem pode funcionar razoavelmente bem
para um jogo com um conjunto limitado de regras. Infelizmente Wesnoth
é um jogo bem extenso e tal abordagem não é facilmente extensível.
Se uma pessoa quiser adicionar um novo tivo de unidade usando esta
abordagem, isso requer adicionar uma nova classe C++ para o jogo.
Adicionalmente, isto não permite diferentes características serem
combinadas também: e se você tiver uma unidade que regenerada,
puder desacelerar inimigos com uma rede, e ficar invisível em uma
floresta? Você teria que escrever uma classe totalmente nova que
duplicasse o código de outras classes.<!-- Such an approach would work reasonably well for a game with a limited set of rules. Unfortunately Wesnoth is quite a large game and such an approach is not easily extendable. If a person wanted to add a new type of unit under this approach, it would require the addition of a new C++ class to the game. Additionally, it does not allow different characteristics to be combined well: what if you had a unit that regenerated, could slow enemies with a net, and was invisible in a forest? You would have to write an entirely new class that duplicates code in the other classes. --></SPAN></P>
<P><SPAN LANG="pt-BR">As unidades de sistema do Wesnoth não usam
herança nenhuma para cumprir suas tarefas. Ao invés disso, elas
usam uma classe unidade para representar instâncias de unidades, e
uma classe unit_type, que representa as características imutáveis
que todas as unidades de um certo tipo compartilham. A classe
unitária tem uma referência para o tipo de objeto que ela é. Todos
os possíveis objetos unit_type são armazenados em um dicionário
mantido globalmente que é carregado quando o documento WML principal
é carregado. <!-- Wesnoth's unit system doesn't use inheritance at all to accomplish this task. Instead, it uses a unit class to represent instances of units, and a unit_type class, which represents the immutable characteristics that all units of a certain type share. The unit class has a reference to the type of object that it is. All the possible unit_type objects are stored in a globally held dictionary that is loaded when the main WML document is loaded. --></SPAN></P>
<P LANG="pt-BR">Um tipo de unidade tem uma lista de todas as
habilidades que uma unidade possui. Por exemplo, um Troll tem a
habilidade de “regeneração” que o permite curar a cada rodada.
Um Saurian Skirmisher tem a habilidade “skirmisher” que o permite
mover entre as linhas inimigas. Reconhecer estas habilidades é
construído no engine – por exemplo, algorítimos de pathfinding
devem checar se a unidades tem o flag “skirmisher” ligado para
ver se ele pode mover livremente pelas linhas inimigas. Esta
abordagem permite aos indivíduos adicionar novas unidades, que
tenham alguma combinação de habilidades feitas pela engine, somente
editando o WML. É claro, isso não permite adicionar habilidades
completamente novas e comportamento novo sem modificar o engine.<!-- A unit type has a list of all the abilities that that unit has. For instance, a Troll has the "regeneration" ability that makes it heal life every turn. A Saurian Skirmisher has the "skirmisher" ability that allows it to move through enemy lines. Recognition of these abilities is built into the engine—for instance, the pathfinding algorithms will check if a unit has the "skirmisher" flag set to see if it can move freely past enemy lines. This approach allows an individual to add new units, which have any combination of abilities made by the engine, by only editing WML. Of course, it doesn't allow adding completely new abilities and unit behavior without modifying the engine. --></P>
<P><SPAN LANG="pt-BR"><SPAN STYLE="font-weight: normal">Adicionalmente,
cada unidade no Wesnoth pode ter qualquer quantidade de formas de
ataque. Por exemplo, um Elvish Archer tem um arco de longo alcance e
também uma espada de ataque de curso alcance. Cada um apresenta
diferentes quantidades de dano e características.</SPAN></SPAN> <SPAN LANG="pt-BR"><SPAN STYLE="font-weight: normal">Pra
representar um ataque, existem classes attack_type, e cada instancia
unit_type tem uma lista de possíveis attack_type.<!-- Additionally, each unit in Wesnoth may have any number of ways to attack. For instance, an Elvish Archer has a long-range bow attack and also a short-range sword attack. Each deals different damage amounts and characteristics. To represent an attack, there is an attack_type class, with every unit_type instance having a list of possible attack_types. --></SPAN></SPAN></P>
<P><SPAN LANG="pt-BR"><SPAN STYLE="font-weight: normal">Para dar cada
unidade mais caráter, Wesnoth tem uma funcionalidade conhecida como
traits. Após recrutamento, a maioria das unidades são associadas a
dois traits randomicamente de uma lista pré-definida. Por exemplo,
uma unidade forte causa mais dano com seu melee attacks, enquanto uma
unidade inteligente precisa menos experiência antes de subir de
nível. Também, é possível para unidades adquirir equipamentos
durante o jogo que as tornem mais poderosas. Por exemplo, deve haver
uma espada que a unidade possa carregar que torne seus ataques mais
danosos. Para implementar traits e equipamentos Wesnoth permite
modificações nas unidades, que são alterações definidas no WML
em estatísticas das unidades. As modificações podem inclusive ser
aplicadas para um certo tipo de ataque. Por exemplo, o strong trait
dá as unidades strong mais capacidade de dano quando atacando corpo
a corpo, mas não quando usando um ataque à distância. <!-- To give each unit more character, Wesnoth has a feature known as traits. Upon recruitment, most units are assigned two traits at random from a predefined list. For instance, a strong unit does more damage with its melee attacks, while an intelligent unit needs less experience before it "levels up." Also, it is possible for units to acquire equipment during the game that make them more powerful. For instance, there might be a sword a unit can pick up that makes their attacks do more damage. To implement traits and equipment Wesnoth allows modifications on units, which are WML-defined alterations to a unit's statistics. The modification can even be applied to certain types of attacks. For instance, the strong trait gives strong units more damage when attacking in melee, but not when using a ranged strike. --></SPAN></SPAN></P>
<P LANG="pt-BR"><SPAN STYLE="font-weight: normal">Permitir
comportamento de unidades completamente configurável com WML seria
um objetivo admirável, portanto é educativo considerar porque
Wesnoth nunca atingiu tal objetivo. WML poderia precisar ser muito
mais flexível do que ela é se ela permitisse comportamento de
unidades arbitrário. Ao invés disso sendo uma linguagem orientada a
dados, WML poderia ter que ser estendida em uma linguagem de
programação plena e que poderia ser intimidadora para vários
aspirantes contribuidores. <!-- Allowing completely configurable unit behavior with WML would be an admirable goal, so it is instructional to consider why Wesnoth has never achieved such a goal. WML would need to be much more flexible than it is if it were to allow arbitrary unit behavior. Rather than being a data-oriented language, WML would have to be extended into a full-fledged programming language and that would be intimidating for many aspiring contributors. --></SPAN></P>
<P><SPAN LANG="pt-BR">Adicionalmente, o Wesnoth AI, que é
desenvolvido em C++, reconhece as habilidades presentes no jogo. Ela
leva em conta a regeneração, invisibilidade, e assim por diante, e
tenta manobrar suas unidades para tirar o melhor proveito destas
diferentes habilidades. Mesmo que uma habilidade da unidade pudesse
ser criada usando WML, seria difícil fazer AI sofisticada o
suficiente para reconhecer essa capacidade e tirar proveito dela.
Implementar uma habilidade sem ser controlada pela AI não seria uma
implementação satisfatória. Da mesma forma, implementar uma
habilidade em WML e depois ter que modificar a AI em C++ para
controlar a habilidade seria um contrassenso.  Portanto, ter unidades
definíveis em WML, porém tendo habilidades escritas no código da
engine é considerado um compromisso razoável que funciona melhor
para os requisitos específicos do Wesnoth. <!-- Additionally, the Wesnoth AI, which is developed in C++, recognizes the abilities present in the game. It takes into account regeneration, invisibility, and so forth, and attempts to maneuver its units to take best advantage of these different abilities. Even if a unit ability could be created using WML, it would be difficult to make the AI sophisticated enough to recognize this ability to take advantage of it. Implementing an ability but not having it accounted for by the AI would not be a very satisfying implementation. Similarly, implementing an ability in WML and then having to modify the AI in C++ to account for the ability would be awkward. Thus, having units definable in WML, but having abilities hard-wired into the engine is considered a reasonable compromise that works best for Wesnoth's specific requirements. --></SPAN></P>
<H2 CLASS="western">25.4. Implementação Wesnoth de Multiplayer<!-- Wesnoth's Multiplayer Implementation --></H2>
<P><SPAN LANG="pt-BR">A implementação multiplayer do Wesnoth
utiliza uma abordagem tão simples quanto possível para implementar
múltiplos jogadores. Se tenta mitigar a possibilidade de ataques
maliciosos no servidor, mas não se faz um esforço serio para evitar
trapassas. Qualquer movimento que é feito no jogo Wesnoth</SPAN><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Ubuntu, sans-serif"><FONT SIZE=3><SPAN LANG="pt-BR"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="text-decoration: none">—</SPAN></SPAN></SPAN></SPAN></FONT></FONT></SPAN></FONT><SPAN LANG="pt-BR">
movimento de uma unidade atacando um inimigo, recrutando uma unidade,
assim por diante</SPAN><FONT COLOR="#000000"><SPAN STYLE="text-decoration: none"><FONT FACE="Ubuntu, sans-serif"><FONT SIZE=3><SPAN LANG="pt-BR"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal"><SPAN STYLE="text-decoration: none">—</SPAN></SPAN></SPAN></SPAN></FONT></FONT></SPAN></FONT><SPAN LANG="pt-BR">
pode ser salvo como um nó WML. Por exemplo, um comando para mover
uma unidade pode ser salvo em um WML como o seguinte: <!-- The Wesnoth multiplayer implementation uses a simple-as-possible approach to implementing multiplayer in Wesnoth. It attempts to mitigate the possibility of malicious attacks on the server, but doesn't make a serious attempt to prevent cheating. Any movement that is made in a Wesnoth game—moving of a unit, attacking an enemy, recruiting a unit, and so forth—can be saved as a WML node. For instance, a command to move a unit might be saved into WML like this: --></SPAN></P>
<PRE CLASS="western">[move]
    x=&quot;11,11,10,9,8,7&quot;
    y=&quot;6,7,7,8,8,9&quot;
[/move]</PRE><P LANG="pt-BR">
Isto mostra o caminho que uma unidade segue como um resultado dos
comandos do jogador. O jogo então tem a capacidade de executar
qualquer comando WML submetido. Isso é muito útil porque significa
que um <I>replay</I> completo pode ser salvo, armazenando o estado
inicial do jogo e então todos os comandos subsequentes. Ser capaz de
rever jogos é útil tanto para os jogadores se observarem jogando,
quanto para auxiliar em certos tipos de relatórios de bugs. <!-- This shows the path that a unit follows as a result of a player's commands. The game then has a facility to execute any such WML command given to it. This is very useful because it means that a complete replay can be saved, by storing the initial state of the game and then all subsequent commands. Being able to replay games is useful both for players to observe each other playing, as well as to help in certain kinds of bug reports. --></P>
<P LANG="pt-BR">Nós decidimos que a comunidade deveria tentar focar
em jogos amistosos e casuais para a implementação do Wesnoth
multiplayer via rede. Ao invés de uma batalha técnica contra
crackers anti-sociais tentando comprometer sistemas de prevenção a
trapassas o projeto simplesmente não tenta arduamente prevenir
trapassas. Uma análise de outros jogos multiplayer indica que
sistemas de ranqueamento competitivo foram a ponto central para
comportamento anti-social. Prevenir deliberadamente tais funções no
servidor reduziu grandemente a motivação para indivíduos
trapacearem. Além disso, os moderadores tentam encorajar uma
comunidade positiva de jogadores onde indivíduos desenvolvem relação
pessoal com outros jogadores e jogam com eles. Isto estabeleceu uma
enfase no relacionamento ao invés da competição. Como resultado
estes esforços tem sido considerado bem sucedidos, enquanto esforços
para hackear maliciosamente o jogo tem sido normalmente isolados. <!-- We decided that the community would try to focus on friendly, casual games for the network multiplayer implementation of Wesnoth. Rather than fight a technical battle against anti-social crackers trying to compromise cheat prevention systems, the project would simply not try hard to prevent cheating. An analysis of other multiplayer games indicated that competitive ranking systems were a key source of anti-social behavior. Deliberately preventing such functions on the server greatly reduced the motivation for individuals to cheat. Moreover the moderators try to encourage a positive gaming community where individuals develop personal rapport with other players and play with them. This placed a greater emphasis on relationships rather than competition. The outcome of these efforts has been deemed successful, as thus far efforts to maliciously hack the game have been largely isolated. --></P>
<P LANG="pt-BR">A implementação multiplayer do Wesnoth consistem em
uma infraestrutura cliente-servidor típica. Um servidor, conhecido
como wesnothd, acceita conexões vindas de clientes Wesnoth, e envia
para o cliente um resumo dos jogos disponíveis. O Wesnoth irá
apresentar um 'lobby' para o jogador que pode escolher um jogo para
se juntar ou criar um novo jogo para outros se juntarem. Uma vez que
os jogadores estejam em um jogo e o jogo comece,  cada instância de
Wesnoth irá gerar comandos WML descrevendo ações realizadas pelos
jogadores. Estes comandos são enviados para o servidor, e então o
servidor as retransmite para todos os outros clientes naquele jogo. O
servidor irá portanto agir como um retransmissor bem simples e leve.
Desde que Wesnoth seja um jogo baseado em turnos, TCP/IP é usado
para todas as comunicações via rede. <!-- Wesnoth's multiplayer implementation consists of a typical client-server infrastructure. A server, known as wesnothd, accepts connections from the Wesnoth client, and sends the client a summary of available games. Wesnoth will display a 'lobby' to the player who can choose to join a game or create a new game for others to join. Once players are in a game and the game starts, each instance of Wesnoth will generate WML commands describing the actions the player makes. These commands are sent to the server, and then the server relays them on to all the other clients in the game. The server will thus act as a very thin, simple relay. The replay system is used on the other clients to execute the WML commands. Since Wesnoth is a turn-based game, TCP/IP is used for all network communication. --></P>
<P LANG="pt-BR">Este sistema também permite observadores facilmente
assistirem um jogo. Um observador pode se juntar a um jogo sendo
executado, neste caso o servidor irá enviar o WML que representa o
estado inicial do jogo, seguido pelo histórico de comandos que tenha
sido executado desde o estado inicial. Isto permite a novos
observadores definir a velocidade para chegar ao estado atual do
jogo. Eles podem ver a história do jogo, entretanto demora para que
o observador chegue à posição atual do jogo. A história do jogo
pode ser adiantada, entretanto mesmo assim isto toma tempo. A
alternativa poderia ser que um dos clientes gerasse uma cópia do
estado atual do WML e enviasse ao novo observador, entretanto esta
abordagem poderia prejudicar os clientes com sobrecarga de
observadores, e poderia facilitar ataques de denial-of-service
através de muitos observadores ligados no jogo. <!-- This system also allows observers to easily watch a game. An observer can join a game in-progress, in which case the server will send the WML representing the initial state of the game, followed by a history of all commands that have been carried out since the start of the game. This allows new observers to get up to speed on the state of the game. They can see a history of the game, although it does take time for the observer to get to the game's current position—the history of commands can be fast forwarded but it still takes time. The alternative would be to have one of the clients generate a snapshot of the game's current state as WML and send it to the new observer; however this approach would burden clients with overhead based on observers, and could facilitate denial-of-service attacks by having many observers join a game. --></P>
<P LANG="pt-BR">É claro, desde que clientes Wesnoth não
compartilham qualquer tipo de estado do jogo entre sí, somente
enviando comandos, é importante que eles concordem com regras sobre
o jogo. O servidor é segmentado por versão, com somente jogadores
usando a mesma versão ou versões capazes de interagir. Jogadores
são imediatamente alertados se seus clientes perderem sincronismo
com outros. Isto também é um sistema útil para prevenir trapassas.
Embora seja bem fácil para jogadores trapacear modificando seus
clientes, qualquer diferença entre versões será imediatamente
sinalizada para os jogadores para que possam lidar com isso. <!-- Of course, since Wesnoth clients do not share any kind of game state with each other, only sending commands, it is important that they agree on the rules of the game. The server is segmented by version, with only players using the same version of the game able to interact. Players are immediately alerted if their client's game becomes out of sync with others. This also is a useful system to prevent cheating. Although it is rather easy for a player to cheat by modifying their client, any difference between versions will immediately be identified to players where it can be dealt with. --></P>
<H2 CLASS="western">25.5. <SPAN LANG="pt-BR">Conclusão</SPAN><!-- Conclusion --></H2>
<P LANG="pt-BR">Nós acreditamos que a beleza da batalha de Wesnoth
como um programa seja como o código foi tornado acessível para uma
variedade de indivíduos. Para atingir este objetivo, o projeto
sempre assumiu compromissos para não parecer elegante de alguma
forma. Deve ser observado que muitos dos programadores mais
talentosos do projeto desaprovam WML por sua sintaxe ineficiente.
Ainda assim, este compromisso possibilita o grande sucesso do
projeto. Hoje Wesnoth pode contar com centenas de campanhas e eras
feitas por usuários, criadas por usuários com pouca ou nenhuma
experiência em programação. Além disso, ele tem inspirado um
número de pessoas a tentar programação como profissão, usando o
projeto como uma ferramenta de aprendizado. Estes são resultados
tangíveis que poucos programas podem igualar. <!-- We believe that the beauty of the Battle for Wesnoth as a program is how it made coding accessible to a wide variety of individuals. To achieve this aim, the project often made compromises that do not look elegant whatsoever in the code. It should be noted that many of the project's more talented programmers frown upon WML for its inefficient syntax. Yet this compromise enabled one of the project's greatest successes. Today Wesnoth can boast of hundreds of user-made campaigns and eras, created mostly by users with little or no programming experience. Furthermore it has inspired a number of people to take up programming as a profession, using the project as a learning tool. Those are tangible accomplishments that few programs can equal. --></P>
<P LANG="pt-BR">Uma das lições chave que um leitor poderia observar
além do esforço Wesnoth é considerar os desafios enfrentados por
programadores menos habilidosos. Isto requer uma consciência sobre o
que impede contribuidores de verdadeiramente realizarem codificação
e desenvolverem suas habilidades. Por exemplo um indivíduo pode
querer contribuir para o programa mas não ter habilidade em
programação. Editores dedicados como emacs ou vim apresentam uma
curva de aprendizado significativa que pode ser assustadora para tais
indivíduos. Portanto WML foi projetada para permitir que um simples
editor de textos possa abrir seus arquivos, dando a qualquer um as
ferramentas para contribuir. <!-- One of the key lessons a reader should take away from Wesnoth's efforts is to consider the challenges faced by lesser skilled programmers. It requires an awareness of what blocks contributors from actually performing coding and developing their skills. For example an individual might want to contribute to the program but does not possess any programming skills. Dedicated technological editors like emacs or vim possess a significant learning curve that might prove daunting for such an individual. Thus WML was designed to allow a simple text editor to open up its files, giving anybody the tools to contribute. --></P>
<P LANG="pt-BR">Entretanto, aumentar a acessibilidade à base de
código não é um objetivo simples de ser atingido. Não existem
regras rápidas e objetivas para aumentar a acessibilidade do código.
Ao invés, isso requer um equilíbrio entre diferentes considerações,
que podem ter consequências negativas que a comunidade precisa
conhecer. Isso é aparente em como o programa lidou com dependências.
Em alguns casos, dependências podem na verdade aumentar as barreiras
para participação, enquanto em outros casos elas podem permitir que
pessoas contribuam mais facilmente. Cada questão precisa ser
considerada caso a caso. <!-- However, increasing a code base's accessibility is not a simple objective to achieve. There are no hard and fast rules for increasing code's accessibility. Rather it requires a balance between different considerations, which can have negative consequences that the community must be aware of. This is apparent in how the program dealt with dependencies. In some cases, dependencies can actually increase barriers to participation, while in others they can allow people to contribute more easily. Every issue must be considered on a case-by-case basis. --></P>
<P><SPAN LANG="pt-BR">Devemos também ser cautelosos para não
exagerar o sucesso do Wesnoth. O projeto aproveita algumas vantagens
que não são facilmente reproduzidas por outros programas. Tornar
código acessível para um público amplo é em parte resultado das
configurações dos programas. Legalmente a licença GNU permite que
alguém abra um arquivo existente, entenda como ele funciona e faça
mudanças. Indivíduos são encorajados para experimentar, aprender e
compartilhar nesta cultura, que pode não ser apropriada para outros
programas. Entretanto esperamos que haja certos elementos que possam
se provar úteis para todos os desenvolvedores e ajudá-los em seu
esforço para encontrar beleza na codificação. <!-- We should also be careful not to overstate some of Wesnoth's successes. The project enjoyed some advantages that are not easily replicated by other programs. Making code accessible to a wider public is partly a result of the program's setting. As an open source program, Wesnoth had several advantages in this regard. Legally the GNU license allows someone to open up an existing file, understand how it works and makes changes. Individuals are encouraged to experiment, learn and share within this culture, which might not be appropriate for other programs. Nevertheless we hope that there are certain elements that might prove useful for all developers and help them in their effort to find beauty in coding. --></SPAN></P>
</BODY>
</HTML>